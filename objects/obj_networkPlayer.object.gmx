<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>0</visible>
  <depth>0</depth>
  <persistent>-1</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///initialize variables

//character
character = "";
//team
team = 0;
// ready - whether player is ready to move to next menu
ready = false;
// name - player name
name = "Player";
//playerId - accumulative global number to identify player
playerId = 0;
//input - input player is using
input = 0;
//gameCharacter - character in game
gameCharacter = noone;
//startX and startY - starting coordinates
startX = 0;
startY = 0;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// server

if (global.haveserver) {
    // connectID - order in which client connected, used in lobby code
    connectID = global.PlayerTotal;
    
    global.PlayerTotal++;
    }

// inputs - array holding the current state of each input
inputs = array_create(array_length_2d(global.controls, 0));
// mouse input
mouseX = 0;
mouseY = 0;

// currentRTT - store the current round trip time for messages
currentRTT = 0;

// ip - ip of client, used for disconnecting
ip = 0;

// dropBuffer - steps before a client is dropped, from not recieving a ping
dropBuffer = 60;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// join lobby

// join the client into the lobby
scr_joinLobby(other);
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// debug

// socketOut - the socket
socketOut = -1;

// messageSuccess - whether the message was succesful sent
messageSuccess = -1;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// drop player if not responding
switch(global.Menu.state) {
    case STATE_LOBBY:
        // just drop
        event_user(1);
    default:
        with (instance_create(room_width/2, room_height/2, obj_inputMessage)) {
            prompt = other.name + " is not responding, drop?";
            ds_list_add(actions, "dropPlayer");
            ds_list_add(actionTitles, "yes");
            ds_list_add(actions, "resetDropBuffer");
            ds_list_add(actionTitles, "no");
            Source = other;
            }
    }
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="11">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// drop player if ping is not keeping him alive

//also delete the socket from our global list of connected clients
with (obj_server) {
    // delete refrence in clients list
    ds_map_delete(Clients, other.ip);
    ds_map_delete(clientMessages, other.ip);
    
    // find index in parallel arrays using client ip
    var index = ds_list_find_index(iplist, other.ip);
    ds_list_delete(iplist, index);
    ds_list_delete(portlist, index);
    
    // delete sequences
    ds_list_delete(sequenceOuts, index);
    ds_map_destroy(sequenceOutQueues[| index]);
    ds_list_delete(sequenceOutQueues, index);
    }

// check if in lobby
var state = global.Menu.state;
if (state == STATE_LOBBY) {
    // leave the client into the lobby
    with (global.Menu) scr_joinLobby(other);
    }

if (state == STATE_GAME) {
    // delete character
    if (instance_exists(gameCharacter))
        instance_destroy(gameCharacter);
    }
    
if (state == STATE_GAME || state == STATE_SCORE) {
    // remove from team
    var index = ds_list_find_index(team.players, self);
    ds_list_delete(team.players, index);
    // delete team if last player
    if (ds_list_empty(team.players)) {
        ds_map_delete(global.Menu.gameTeams, team);
        instance_destroy(team);
        }
    }

// destory self
instance_destroy();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="4">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///create character
if (team.tLives &gt; 0) {
    with (pos_character) {
        other.startX = x;
        other.startY = y;
        
        //create character
        other.gameCharacter = instance_create(other.startX, other.startY, obj_character);
        other.gameCharacter.playerInput = other.input; // negative one for client control
        other.gameCharacter.InputPlayer = other; // set network player for input
        other.gameCharacter.playerId = other.playerId;
        other.gameCharacter.team = other.team;
        other.gameCharacter.playerName = other.name;
        other.gameCharacter.inputType = other.inputs[KEY_TYPE];
        
        //get sprite
        other.gameCharacter.sprite_index = other.sprite_index;
        
        //destroy self, so other character will create elsewhere
        instance_destroy();
        
        //exit - only create one
        exit;
        }
    }
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
