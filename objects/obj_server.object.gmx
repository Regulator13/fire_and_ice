<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>-1</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Create server and initialise map
global.counter = 0;
image_blend = c_red;
global.haveserver = true;

//counters
global.serverEntitySprites = 0;
global.PlayerTotal = 0;


// create our server. Server creation may fail if there is already a server running. If it does fail, delete eveything and kill this instance
var alignment = 1;
broadcast_buffer = buffer_create(32, buffer_fixed, alignment);
gameBuffer = buffer_create(32, buffer_grow, alignment);//buffer_create(16384, buffer_fixed, alignment);
Clients = ds_map_create();
iplist = ds_list_create();
portlist = ds_list_create();
sequenceOuts = ds_list_create();
sequenceOutQueues = ds_list_create();

// clientMessages - messages to the client, connection, login, game
clientMessages = ds_map_create();
// clientBuffer - buffer for small client messages
confirmBuffer = buffer_create(24, buffer_fixed, alignment);

// Try and create the actual server
server = network_create_server(global.ServerType, 6510, 32 );
if( server&lt;0 ){    
    // If theres already a server running, shut down and delete.
    instance_destroy();
}

// Setup a timer so we can broadcast the server IP out to local clients looking...
alarm[0]=60;

//create menu
alarm[1] = 1;

// NOW DONE INDIVIDUALLY
/*
//realiabilty, ordering, and congestion avoidance for UDP
sequenceOut = 0; // stores latest packet sequence that the server has sent out
sequenceOutMax = SEQUENCE_MAX; //65,535 is the max for buffer_u16
sequenceOutQueue = ds_map_create();
*/

//startBuffer - small buffer to allow first client to connect
startBuffer = 30;
sendBuffer = 0;

// serverDebug - whether or not to draw server debug information
serverDebug = false;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// player colours
// List of random player colours....
ColourArray[0] = c_white;
ColourArray[1] = c_red;
ColourArray[2] = c_blue;
ColourArray[3] = c_yellow;
ColourArray[4] = c_green;
ColourArray[5] = c_purple;
ColourArray[6] = c_aqua;
ColourArray[7] = c_maroon;
ColourArray[8] = c_orange;
ColourArray[9] = c_teal;
ColourArray[10] = c_olive;
ColourArray[11] = c_ltgray;
ColourArray[12] = c_dkgray;
ColourArray[13] = c_navy;
ColourArray[14] = $ff8080;
ColourArray[15] = $80ff80;
colourindex = 0;

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///close server

// destroy server
global.haveserver = false;

// destroy network
network_destroy(server);

// destroy any client persistent objects
var count = ds_list_size(iplist); // get the amount of clients connected

// check for clients to send confirmations
for (i = 0; i &lt; count; i++) { 
    //get the ip of the client to get the message
    var ip = ds_list_find_value(iplist, i);
    
    // get the network player
    var inst = ds_map_find_value(Clients, ip);
    
    // remove network player from lobby
    scr_joinLobby(inst);
    
    // destroy the persistent network player object
    instance_destroy(inst);
    
    // remove the player's specific sequenceOutQueue
    ds_map_destroy(sequenceOutQueues[| i]); 
    }

// delete buffers
buffer_delete(broadcast_buffer);
buffer_delete(gameBuffer);
buffer_delete(confirmBuffer);
// destroy lists
ds_list_destroy(iplist);
ds_list_destroy(portlist);
ds_list_destroy(sequenceOuts);
ds_list_destroy(sequenceOutQueues);
// destroy maps
ds_map_destroy(Clients);
ds_map_destroy(clientMessages);
ds_list_destroy(sequenceOutQueues);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Broadcast our location occasionally. Clients pick this up and can then display servers to the user. 

buffer_seek( broadcast_buffer, buffer_seek_start, 0 );
buffer_write( broadcast_buffer, buffer_string, global.ServerName );
network_send_broadcast( server, 6511, broadcast_buffer, buffer_tell(broadcast_buffer) );

// Broadcast once a second...
alarm[0]=60;

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// client messages
    // once a frame, we send clients any priority message, if not in game
    var count = ds_list_size(iplist); // get the amount of clients connected

    // if there is at least one client, continue
    if (count &gt; 0) {
        // send appropiate game data
        switch(global.Menu.state) {
            case STATE_LOBBY:
                // write the lobby information to the sending buffer
                scr_writeLobby();
                
                // check for clients to send confirmations
                for (i = 0; i &lt; count; i++) { 
                    //get the ip of the client to get the message
                    var ip = ds_list_find_value(iplist, i);
                    
                    // find the type of message to send
                    var message = ds_map_find_value(clientMessages, ip);
                    
                    // check if need to send a confirmation
                    if (message != SERVER_PLAY) {
                        // send neccesary confirmation
                        
                        // get the client message buffer
                        var buff = confirmBuffer;
                        
                        // reset buffer to start - Networking ALWAYS reads from the START of the buffer
                        buffer_seek(buff, buffer_seek_start, 0);
                        
                        // write msgId
                        buffer_write(buff, buffer_s8, message);
                        
                        // write packet sequence
                        buffer_write(buff, buffer_u8, 0);//sequenceOut); Written in send buffer
                        
                        // send confirmation to the client
                        scr_sendBuffer(ip, i, buff);
                        }
                    else {
                        // send pre_written lobby data
                        scr_sendBuffer(ip, i, gameBuffer);
                        }
                    }
                break;
            case STATE_PATHS:
                // write the path information to the sending buffer
                scr_writePaths();
                
                // check for clients to send information
                for (i = 0; i &lt; count; i++) { 
                    //get the ip of the client to get the message
                    var ip = ds_list_find_value(iplist, i);
                    
                    // find the type of message to send
                    var message = ds_map_find_value(clientMessages, ip);
                    
                    // check if client is logged in
                    if (message == SERVER_PLAY) {
                        // send pre_written data
                        scr_sendBuffer(ip, i, gameBuffer);
                        }
                    }
                break;
            case STATE_GAME:
                // write the game information to the sending buffer
                scr_writeGame();
                
                // check for clients to send information
                for (i = 0; i &lt; count; i++) { 
                    //get the ip of the client to get the message
                    var ip = ds_list_find_value(iplist, i);
                    
                    // find the type of message to send
                    var message = ds_map_find_value(clientMessages, ip);
                    
                    // check if client is logged in
                    if (message == SERVER_PLAY) {
                        // update the buffer with client specific information
                        scr_writeGameUpdate(ip, i);
                        
                        // send pre_written data
                        scr_sendBuffer(ip, i, gameBuffer);
                        }
                    }
                break;
            case STATE_SCORE:
                // write the score information to the sending buffer
                scr_writeScore();
                
                // check for clients to send information
                for (i = 0; i &lt; count; i++) { 
                    //get the ip of the client to get the message
                    var ip = ds_list_find_value(iplist, i);
                    
                    // find the type of message to send
                    var message = ds_map_find_value(clientMessages, ip);
                    
                    // check if client is logged in
                    if (message == SERVER_PLAY) {
                        // send pre_written data
                        scr_sendBuffer(ip, i, gameBuffer);
                        }
                    }
                break;
            }
        }
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// update server sequence once for all messages

// NOW DONE INDIVIDUALLY IN SEND BUFFER
/*
// increment the sequence
sequenceOut ++;

// keep the sequence in bounds
if (sequenceOut &gt;= sequenceOutMax) sequenceOut = 0;

// add packet to queue for checking with client's acks
ds_map_replace(sequenceOutQueue, sequenceOut, current_time);
// all values are cycled through, every 255 steps, keeping things up to date
*/
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// server debug
if (keyboard_check_pressed(vk_f1)) {
    // toggle whether to draw server debug
    serverDebug = scr_toggle(serverDebug);
    }
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="68">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Server network control

//find buffer
var buff = ds_map_find_value(async_load, "buffer");
//find start since the connection is UDP and not sorted out for us
buffer_seek(buff, buffer_seek_start, 0);

//read message id
var msgId = buffer_read(buff, buffer_s8);

switch (msgId) {
    case CLIENT_CONNECT:
        // client connecting
        scr_connectClient();
        break;
    case CLIENT_LOGIN:
        // client logging in
        scr_loginClient();
        break;
    case CLIENT_PLAY:
        //all other sockets are connected client sockets, and we have recieved commands from them.
        scr_serverRecievedData();
        break;
    }
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="3">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///close server

// destroy server
global.haveserver = false;

// destroy network
network_destroy(server);

// destroy any client persistent objects
var count = ds_list_size(iplist); // get the amount of clients connected

// check for clients to send confirmations
for (i = 0; i &lt; count; i++) { 
    //get the ip of the client to get the message
    var ip = ds_list_find_value(iplist, i);
    
    // get the network player
    var inst = ds_map_find_value(Clients, ip);
    
    // remove network player from lobby
    scr_joinLobby(inst);
    
    // destroy the persistent network player object
    instance_destroy(inst);
    
    // remove the player's specific sequenceOutQueue
    ds_map_destroy(sequenceOutQueues[| i]); 
    }

// delete buffers
buffer_delete(broadcast_buffer);
buffer_delete(gameBuffer);
buffer_delete(confirmBuffer);
// destroy lists
ds_list_destroy(iplist);
ds_list_destroy(portlist);
ds_list_destroy(sequenceOuts);
ds_list_destroy(sequenceOutQueues);
// destroy maps
ds_map_destroy(Clients);
ds_map_destroy(clientMessages);
ds_list_destroy(sequenceOutQueues);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// draw server debug information
if (serverDebug) {
    // setup drawing
    draw_set_color(c_dkgray);
    draw_set_alpha(0.5);
    
    // set draw offset
    var drawOffset = 0;
    var yOffset = 20;
    
    // once a frame, we send clients any priority message, if not in game
    var count = ds_list_size(iplist); // get the amount of clients connected
    
    // draw background
    draw_rectangle(0, 0, 500, count*2*yOffset+30+10, false);
    
    // setup drawing
    draw_set_halign(fa_left);
    draw_set_font(fnt_command);
    draw_set_color(c_red);
    
    // draw the amount of players
    draw_text(10,10,"players: "+string(global.PlayerTotal));
    
    // check for clients to send confirmations
    for (i = 0; i &lt; count; i++) { 
        //get the ip of the client to get the message
        var ip = ds_list_find_value(iplist, i);
        
        // find the type of message to send
        var message = ds_map_find_value(clientMessages, ip);
        
        // get the network player
        var inst = ds_map_find_value(Clients, ip);
        
        // get the latest sequence out
        var sequenceOut = sequenceOuts[| i];
        
        // draw RTT
        
        draw_text(10, 30+yOffset*drawOffset, string(ip));
        draw_text(340, 30+yOffset*drawOffset, string(inst.currentRTT));
        draw_text(160, 30+yOffset*drawOffset, scr_drawNetworkState(message));
        if (inst.alarm[0] &lt; inst.dropBuffer-2) {
            draw_text(400, 30+yOffset*drawOffset, string(inst.alarm[0]));
            }
        // increment drawOffset
        drawOffset++;
        draw_text(10, 30+yOffset*drawOffset, "Socket Out: " + string(inst.socketOut));
        draw_text(120, 30+yOffset*drawOffset, "Message Success: " + string(inst.messageSuccess));
        draw_text(340, 30+yOffset*drawOffset, "Sequence Out: " + string(sequenceOut));
        // increment drawOffset
        drawOffset++;
        }
    
    // reset alpha
    draw_set_alpha(1);
    }
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
