<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>-1</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// server game data

// add all basic sprites to send into a list
basicSprites = ds_list_create();
basicImages = ds_list_create();
basicXs = ds_list_create();
basicYs = ds_list_create();

// add all characters to send into a list
characterSprites = ds_list_create();
characterImages = ds_list_create();
characterXs = ds_list_create();
characterYs = ds_list_create();
characterHPs = ds_list_create();
characterEnergys = ds_list_create();
characterNames = ds_list_create();

// lasers order: x, y, laserX
lasers = ds_list_create();

// water_height
water_height = 0;

// disconnectBuffer - buffer before asking to disconnect
disconnectBuffer = 60;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///initialize the client
PlayerName = global.ServerName;   //get the name that was selected (it's a server OR player name)

//server IP and port, needed to send packets
ip = global.connectip;
port = 6510;

//create a buffer for the network messages
var alignment = 1;
buff = buffer_create(256, buffer_grow, alignment);
//create a UDP socket
client = network_create_socket(global.ServerType);
//remember this socket ID so the server can ignore it (if we have a local server)

// remember client id
global.Client = id;

//attempt to connect to server
global.NetworkState = NETWORK_CONNECT;
connectBuffer = 30; //give client one secound to connect

//realiabilty, ordering, and congestion avoidance for UDP
sequenceIn = -1; // stores latest packet sequence that the client has recieved
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// debug

// clientDebug - whether to show debug for the client
clientDebug = false;

// msgIDin - the latest server message ID
msgIDin = 0;

// socketIn - the socket id coming in from the server
socketIn = -1;

// serverIP - IP address of where message are coming in from
serverIP = -1;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// close client

// destroy network
network_destroy(client);

// destroy buffers
buffer_delete(buff);

// destroy lists
ds_list_destroy(basicSprites);
ds_list_destroy(basicImages);
ds_list_destroy(basicXs);
ds_list_destroy(basicYs);
ds_list_destroy(characterSprites);
ds_list_destroy(characterImages);
ds_list_destroy(characterXs);
ds_list_destroy(characterYs);
ds_list_destroy(characterHPs);
ds_list_destroy(characterEnergys);
ds_list_destroy(characterNames);
ds_list_destroy(lasers);

// clear menu server data
ds_list_clear(global.Menu.serverData);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// disconnect if server is not responding
with (instance_create(room_width/2, room_height/2, obj_inputMessage)) {
    prompt = "Server not responding, disconnect?";
    switch(global.Menu.state) {
        case STATE_LOBBY:
            ds_list_add(actions, "backOnlineLobby");
            break;
        case STATE_PATHS:
            ds_list_add(actions, "backOnlinePaths");
            break;
        case STATE_GAME:
            ds_list_add(actions, "backOnlineGame");
            break;
        case STATE_SCORE:
            ds_list_add(actions, "backOnlineScore");
            break;
        }
    ds_list_add(actionTitles, "yes");
    ds_list_add(actions, "resetDisconnectBuffer");
    ds_list_add(actionTitles, "no");
    }
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>other</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///network control
switch(global.NetworkState) {
    case(NETWORK_CONNECT): //attempt to connect to server
        if (connectBuffer &gt; 0) {
            //move to start of buffer. Networking ALWAYS takes the data from the START of a buffer.
            buffer_seek(buff, buffer_seek_start, 0);
    
            //write msgId
            buffer_write(buff, buffer_s8, CLIENT_CONNECT);
    
            // Send this to the server
            var message = network_send_udp(client,ip,port,buff,buffer_tell(buff));
            if(message &lt;= 0){ //network_send_udp returns number less than one if message fails
                if !(instance_exists(obj_inputMessage)) {
                //if we can't connect, show and error and restart... could be more graceful :)
                with (instance_create(room_width/2, room_height/2, obj_inputMessage)) {
                    prompt = "ERROR: Can not connect to server";
                    ds_list_add(actions, "backOnlineLobby");
                    ds_list_add(actionTitles, "Back");
                    }
                    }
                }
            
            //lower connect buffer
            connectBuffer --;
            }
        else {
            // time for connect ran out
            if !(instance_exists(obj_inputMessage)) {
            with (instance_create(room_width/2, room_height/2, obj_inputMessage)) {
                prompt = "ERROR: Connection time ran out";
                ds_list_add(actions, "backOnlineLobby");
                ds_list_add(actionTitles, "Back");
                }
                }
            }
        
        //break
        break;
    case(NETWORK_LOGIN): //login 
        //client has connected to the server, so send our "player name"
        scr_sendLogin(PlayerName);
        //break
        break;
    case(NETWORK_PLAY): //game is running
        scr_sendKeepAlive();
        
        //break
        break;
    }
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// client input
if (global.NetworkState == NETWORK_PLAY) {
    scr_sendInput();
    /*
    with(global.Menu) {
        switch(state) {
            case STATE_LOBBY:
                // join input
                if (keyboard_check_pressed(ord('F')))
                    with(other) scr_sendKey(ord('F'), 1);
                else if (keyboard_check_released(ord('F')))
                    with(other) scr_sendKey(ord('F'), 0);
                // ready input
                if (keyboard_check_pressed(ord('T')))
                    with(other) scr_sendKey(ord('T'), 1);
                else if (keyboard_check_released(ord('T')))
                    with(other) scr_sendKey(ord('T'), 0);
                // up input
                if (keyboard_check_pressed(ord('W')))
                    with(other) scr_sendKey(ord('W'), 1);
                else if (keyboard_check_released(ord('W')))
                    with(other) scr_sendKey(ord('W'), 0);
                // down input
                if (keyboard_check_pressed(ord('S')))
                    with(other) scr_sendKey(ord('S'), 1);
                else if (keyboard_check_released(ord('S')))
                    with(other) scr_sendKey(ord('S'), 0);
                // left input
                if (keyboard_check_pressed(ord('A')))
                    with(other) scr_sendKey(ord('A'), 1);
                else if (keyboard_check_released(ord('A')))
                    with(other) scr_sendKey(ord('A'), 0);
                // right input
                if (keyboard_check_pressed(ord('D')))
                    with(other) scr_sendKey(ord('D'), 1);
                else if (keyboard_check_released(ord('D')))
                    with(other) scr_sendKey(ord('D'), 0);
            case STATE_GAME:
                // send mouse position
                with (other) scr_sendMouse(mouse_x, mouse_y);
                // jump input
                if (keyboard_check_pressed(vk_space))
                    with(other) scr_sendKey(ord('F'), 1);
                else if (keyboard_check_released(vk_space))
                    with(other) scr_sendKey(ord('F'), 0);
                // mouse input
                if (mouse_check_button_pressed(mb_left))
                    with(other) scr_sendKey(ord('G'), 1);
                if (mouse_check_button_released(mb_left))
                    with(other) scr_sendKey(ord('G'), 0);
                if (mouse_check_button_pressed(mb_right))
                    with(other) scr_sendKey(ord('H'), 1);
                if (mouse_check_button_released(mb_right))
                    with(other) scr_sendKey(ord('H'), 0);
                // up input
                if (keyboard_check_pressed(ord('W')))
                    with(other) scr_sendKey(ord('W'), 1);
                else if (keyboard_check_released(ord('W')))
                    with(other) scr_sendKey(ord('W'), 0);
                // down input
                if (keyboard_check_pressed(ord('S')))
                    with(other) scr_sendKey(ord('S'), 1);
                else if (keyboard_check_released(ord('S')))
                    with(other) scr_sendKey(ord('S'), 0);
                // left input
                if (keyboard_check_pressed(ord('A')))
                    with(other) scr_sendKey(ord('A'), 1);
                else if (keyboard_check_released(ord('A')))
                    with(other) scr_sendKey(ord('A'), 0);
                // right input
                if (keyboard_check_pressed(ord('D')))
                    with(other) scr_sendKey(ord('D'), 1);
                else if (keyboard_check_released(ord('D')))
                    with(other) scr_sendKey(ord('D'), 0);
            }
        }
    */
    }
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="68">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///networking code
var eventid = ds_map_find_value(async_load, "id");
socketIn = eventid; // the socket id coming from the server
serverIP = ds_map_find_value(async_load, "ip");

//show_debug_message(string(eventid));
//is this message for our socket?
if(client == eventid) {
    // if in a state that needs a confirmation
    if (global.NetworkState == NETWORK_CONNECT || global.NetworkState == NETWORK_LOGIN) {
        // read buffer data
        var buffer = ds_map_find_value(async_load, "buffer");
        
        // find start since the connection is UDP and not sorted out for us
        buffer_seek(buffer, buffer_seek_start,0);
        
        // read msgId, confirmation message, or game message
        var msgId = buffer_read(buffer, buffer_s8);
        
        // set msgIDin for debug purposes
        msgIDin = msgId;
        
        // read sequence
        var sequence = buffer_read(buffer, buffer_u8);
        
        // if more recent message, check
        if (scr_sequenceMoreRecent(sequence, sequenceIn, SEQUENCE_MAX)) { //this package is newer and therefore requires an update, 65,535 is for buffer_u16
            // update sequenceIn
            sequenceIn = sequence;
            
            // update disconnect buffer
            alarm[0] = disconnectBuffer;
            
            // check if server is confirming a connection
            if (global.NetworkState == NETWORK_CONNECT &amp;&amp; msgId == SERVER_CONNECT) {
                // connection confirmed! move to login state
                global.NetworkState = NETWORK_LOGIN;
                }
            // check if server is confirming a login
            if (global.NetworkState == NETWORK_LOGIN &amp;&amp; msgId == SERVER_LOGIN) {
                // connection confirmed! move to login state
                global.NetworkState = NETWORK_PLAY;
                }
            // game check is handled later
            }
        }
    }
//show_debug_message(string("next"));
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///game networking code
    var eventid = ds_map_find_value(async_load, "id");
    
    //is this message for our socket?
    if(client == eventid) {
        if (global.NetworkState = NETWORK_PLAY) {
            //read all data....
            var buff = ds_map_find_value(async_load, "buffer");
            
            //find start since the connection is UDP and not sorted out for us
            buffer_seek(buff, buffer_seek_start, 0);
            
            //read msgId, needed so server can ignore it's own commands
            var msgId = buffer_read(buff, buffer_s8);
            // update debug
            msgIDin = msgId;
            
            if (msgId == SERVER_PLAY) { //server message, low priority
                //read sequence
                var sequence = buffer_read(buff, buffer_u8);
                if (scr_sequenceMoreRecent(sequence, sequenceIn, SEQUENCE_MAX)) { //this package is newer and therefore requires an update, 65,535 is for buffer_u16
                    //update sequenceIn
                    sequenceIn = sequence;
                    
                    // update disconnect buffer
                    alarm[0] = disconnectBuffer;
                    
                    //get state
                    var state = buffer_read(buff, buffer_u8);
                    switch(state) {
                        case STATE_LOBBY: // lobby
                            // lobby updates
                            
                            // get the amount of players
                            var players = buffer_read(buff,buffer_u8);
                            // temporarily hold server data, local because it will be called a lot of times
                            serverData = ds_list_create();
                            // read the data
                            for(var i=0;i&lt;players;i++){
                                ds_list_add(serverData, buffer_read(buff,buffer_u8));       // team
                                ds_list_add(serverData, buffer_read(buff,buffer_bool));     // ready
                                ds_list_add(serverData, buffer_read(buff,buffer_string));   // name
                                ds_list_add(serverData, buffer_read(buff,buffer_string));   // character
                                }
                            // copy loaded data to menu
                            ds_list_copy(global.Menu.serverData, serverData);
                            // delete temporary list
                            ds_list_destroy(serverData);
                            break;
                        case STATE_PATHS: // paths menu
                            // path updates
                            if (global.Menu.state == STATE_PATHS) {
                                // get the amount of paths
                                var paths = buffer_read(buff, buffer_u8);
                                
                                // temporarily hold server data, local because it will be called a lot of times
                                serverData = ds_list_create();
                                ds_list_add(serverData, buffer_read(buff,buffer_u8));   // selected path
                                // read the data
                                for(var i = 0; i &lt; paths; i++){
                                    ds_list_add(serverData, buffer_read(buff,buffer_string));   // name
                                    ds_list_add(serverData, buffer_read(buff,buffer_string));   // score
                                    ds_list_add(serverData, buffer_read(buff,buffer_string));   // length
                                    }
                                // copy loaded data to menu
                                ds_list_copy(global.Menu.serverData, serverData);
                                // delete temporary list
                                ds_list_destroy(serverData);
                                }
                            else {
                                // switch to path menu
                                with (global.Menu) event_user(1);
                                }
                            break;
                        case STATE_GAME:
                            // game updates
                            if (global.Menu.state == STATE_GAME &amp;&amp; room == rm_level) {
                                // hold space for specific camera x and y
                                var cameraX = buffer_read(buff, buffer_s16);
                                var cameraY = buffer_read(buff, buffer_s16);
                                if (cameraX != -1 &amp;&amp; cameraY != -1) {
                                    obj_camera.x = cameraX;
                                    obj_camera.y = cameraY;
                                    }
                                
                                // send water height
                                water_height = buffer_read(buff, buffer_u16);
                                
                                // get the amount of teams
                                var teams = buffer_read(buff, buffer_u8);
                                
                                // temporarily hold server data, local because it will be called a lot of times
                                serverData = ds_list_create();
                                
                                ds_list_add(serverData, teams); // add the amount of teams
                                
                                // read the team data
                                for(var i = 0; i &lt; teams; i++){
                                    var  exists = buffer_read(buff, buffer_bool); // whether the team exists
                                    ds_list_add(serverData, exists); // add whether the teams exists
                                    
                                    if (exists) {
                                        var players = buffer_read(buff, buffer_u8); // amount of players on team
                                        ds_list_add(serverData, players); // add amount of players for the team
                                        
                                        ds_list_add(serverData, buffer_read(buff, buffer_string)); // get team name
                                        ds_list_add(serverData, buffer_read(buff, buffer_string)); // get team score
                                        ds_list_add(serverData, buffer_read(buff, buffer_string)); // get team level
                                        ds_list_add(serverData, buffer_read(buff, buffer_string)); // get team lives
                                        
                                        for (cp = 0; cp &lt; players; cp++) {
                                            ds_list_add(serverData, buffer_read(buff, buffer_s16)); // get player sprite
                                            
                                            var characterExists = buffer_read(buff, buffer_bool); // check if player alive
                                            ds_list_add(serverData, characterExists);   // if character is alive
                                            if (characterExists) {
                                                ds_list_add(serverData, buffer_read(buff, buffer_u8));   // hp
                                                ds_list_add(serverData, buffer_read(buff, buffer_u8));   // energy
                                                }
                                            }
                                        }
                                    }
                                
                                // copy loaded data to menu
                                ds_list_copy(global.Menu.serverData, serverData);
                                
                                //for (i = 0; i &lt; ds_list_size(serverData); i++) show_debug_message(string(ds_list_find_value(serverData, i)));
                                
                                // delete temporary list
                                ds_list_destroy(serverData);
                                
                                // gather sprite information
                                
                                // add all basic sprites to send into a list
                                ds_list_clear(basicSprites);
                                ds_list_clear(basicImages);
                                ds_list_clear(basicXs);
                                ds_list_clear(basicYs);
                                
                                // add all characters to send into a list
                                ds_list_clear(characterSprites);
                                ds_list_clear(characterImages);
                                ds_list_clear(characterXs);
                                ds_list_clear(characterYs);
                                ds_list_clear(characterHPs);
                                ds_list_clear(characterEnergys);
                                ds_list_clear(characterNames);
                                
                                // add all lasers into a list
                                ds_list_clear(lasers);
                                
                                // send sprite information
                                var basicSpritesSize = buffer_read(buff, buffer_u16); //buffer_u16 MAX: ?
                                var characterSpritesSize = buffer_read(buff, buffer_u8); //buffer_u8 MAX: 255
                                var lasersSize = buffer_read(buff, buffer_u8); //buffer_u8 MAX: 255
                                
                                // send all basic sprites
                                for (i = 0; i &lt; basicSpritesSize; i++) {
                                    ds_list_add(basicSprites, buffer_read(buff, buffer_s16));   // sprite
                                    ds_list_add(basicImages, buffer_read(buff, buffer_s8));     // image index
                                    ds_list_add(basicXs, buffer_read(buff, buffer_s16));        // X
                                    ds_list_add(basicYs, buffer_read(buff, buffer_s16));        // Y
                                    }
                                
                                // send all character sprites
                                for (i = 0; i &lt; characterSpritesSize; i++) {
                                    ds_list_add(characterSprites, buffer_read(buff, buffer_s16));   // sprite
                                    ds_list_add(characterImages, buffer_read(buff, buffer_s8));     // image index
                                    ds_list_add(characterXs, buffer_read(buff, buffer_s16));        // X
                                    ds_list_add(characterYs, buffer_read(buff, buffer_s16));        // Y
                                    ds_list_add(characterHPs, buffer_read(buff, buffer_u8));        // hp
                                    ds_list_add(characterEnergys, buffer_read(buff, buffer_u8));    // energy
                                    ds_list_add(characterNames, buffer_read(buff, buffer_string));  // name
                                    }
                                
                                // send all character sprites
                                for (i = 0; i &lt; lasersSize; i+=3) {
                                    ds_list_add(lasers, buffer_read(buff, buffer_s16)); // x
                                    ds_list_add(lasers, buffer_read(buff, buffer_s16)); // y
                                    ds_list_add(lasers, buffer_read(buff, buffer_s16)); // laserX
                                    }
                                /*
                                show_debug_message("size" + string(basicSpritesSize) + " " + string(characterSpritesSize));
                                for (i = 0; i &lt; ds_list_size(basicSprites); i++) {
                                    show_debug_message("sprite:" + string(ds_list_find_value(basicSprites, i)));
                                    show_debug_message("image:" + string(ds_list_find_value(basicImages, i)));
                                    show_debug_message("x    : " + string(ds_list_find_value(basicXs, i)));
                                    show_debug_message("y    : " + string(ds_list_find_value(basicYs, i)));
                                    }
                                for (i = 0; i &lt; ds_list_size(characterSprites); i++) {
                                    show_debug_message("sprite:" + string(ds_list_find_value(characterSprites, i)));
                                    show_debug_message("image:" + string(ds_list_find_value(characterImages, i)));
                                    show_debug_message("x    : " + string(ds_list_find_value(characterXs, i)));
                                    show_debug_message("y    : " + string(ds_list_find_value(characterYs, i)));
                                    }
                                */
                                }
                            else if (global.Menu.state == STATE_PATHS) {
                                // switch to game menu
                                with (global.Menu) event_user(2);
                                }
                            else if (global.Menu.state == STATE_SCORE) {
                                // switch to game menu
                                scr_stateSwitch(STATE_SCORE, STATE_GAME);
                                }
                            break;
                        case STATE_SCORE: // score screen
                            // score screen updates
                            if (global.Menu.state = STATE_SCORE) {
                                // temporarily hold server data, local because it will be called a lot of times
                                serverData = ds_list_create();
                                
                                ds_list_add(serverData, buffer_read(buff, buffer_string)); // add the message
                                ds_list_add(serverData, buffer_read(buff, buffer_string)); // add the seed
                                ds_list_add(serverData, buffer_read(buff, buffer_string)); // add the water delay
                                
                                // get the amount of teams
                                var teams = buffer_read(buff, buffer_u8);
                                
                                ds_list_add(serverData, teams); // add the amount of teams
                                
                                // read the team data
                                for(var i = 0; i &lt; teams; i++){
                                    var  exists = buffer_read(buff, buffer_bool); // whether the team exists
                                    ds_list_add(serverData, exists); // add whether the teams exists
                                    
                                    if (exists) {
                                        var players = buffer_read(buff, buffer_u8); // amount of players on team
                                        ds_list_add(serverData, players); // add amount of players for the team
                                        
                                        ds_list_add(serverData, buffer_read(buff, buffer_string)); // get team name
                                        ds_list_add(serverData, buffer_read(buff, buffer_string)); // get team score
                                        ds_list_add(serverData, buffer_read(buff, buffer_string)); // get team level
                                        ds_list_add(serverData, buffer_read(buff, buffer_string)); // get team lives
                                        
                                        for (cp = 0; cp &lt; players; cp++) {
                                            ds_list_add(serverData, buffer_read(buff, buffer_s16)); // get player sprite
                                            
                                            var characterExists = buffer_read(buff, buffer_bool); // check if player alive
                                            ds_list_add(serverData, characterExists);   // if character is alive
                                            if (characterExists) {
                                                ds_list_add(serverData, buffer_read(buff, buffer_u8));   // hp
                                                ds_list_add(serverData, buffer_read(buff, buffer_u8));   // energy
                                                }
                                            }
                                        }
                                    }
                                
                                // copy loaded data to menu
                                ds_list_copy(global.Menu.serverData, serverData);
                                
                                // delete temporary list
                                ds_list_destroy(serverData);
                                }
                            else {
                                scr_stateSwitch(STATE_GAME, STATE_SCORE);
                                }
                            break;
                        }
                    }
                }
            }
        }
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="3">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// close client
network_destroy(client);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// draw client debug information
if (clientDebug) {
    // setup drawing
    draw_set_color(c_dkgray);
    draw_set_alpha(0.5);
    
    // set draw offset
    var drawOffset = 0;
    var yOffset = 20;
    var count = 9;
    
    // draw background
    draw_rectangle(0, 0, 500, count*yOffset+30+10, false);
    
    // setup drawing
    draw_set_halign(fa_left);
    draw_set_font(fnt_command);
    draw_set_color(c_red);
    
    // draw client informtion
    draw_text(10, 10, "CLIENT DEBUG");
    draw_text(10, 30+yOffset*drawOffset++, "Server Message Info:");
    draw_text(10, 30+yOffset*drawOffset++, "Socket In: " + string(socketIn));
    draw_text(10, 30+yOffset*drawOffset++, "Server IP: " + string(serverIP));
    draw_text(10, 30+yOffset*drawOffset++, "Sequence In: " + string(sequenceIn));
    draw_text(10, 30+yOffset*drawOffset++, "msgID In: " + scr_msgIDtoString(msgIDin));
    drawOffset++;// skip a space
    draw_text(10, 30+yOffset*drawOffset++, "Client State Info:");
    draw_text(10, 30+yOffset*drawOffset++, "Client Socket: " + string(client));
    draw_text(10, 30+yOffset*drawOffset++, "Network State: " + scr_networkStateToString(global.NetworkState));
    
    // reset alpha
    draw_set_alpha(1);
    }
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// draw server data
draw_set_alpha(1);
if (view_current == 0) {
    if (global.Menu.state == STATE_GAME) {
        // draw all basic sprites
        var sprites = ds_list_size(basicSprites);
        for (i = 0; i &lt; sprites; i++) {
            draw_sprite(ds_list_find_value(basicSprites, i), ds_list_find_value(basicImages, i), ds_list_find_value(basicXs, i), ds_list_find_value(basicYs, i));
            }
        
        // draw all character sprites
        var sprites = ds_list_size(characterSprites);
        for (i = 0; i &lt; sprites; i++) {
            var cx = ds_list_find_value(characterXs, i);
            var cy = ds_list_find_value(characterYs, i);
            
            // draw sprite
            draw_sprite(ds_list_find_value(characterSprites, i), ds_list_find_value(characterImages, i), cx, cy);
            
            // draw bars
            draw_healthbar(cx, cy-4, cx+17, cy-8, ds_list_find_value(characterHPs, i),c_white,c_red,c_green,0,false,true); // hp
            draw_healthbar(cx, cy, cx+17, cy-4,ds_list_find_value(characterEnergys, i),c_white,c_white,c_teal,0,false,true); // energy
            
            // draw name
            draw_set_alpha(0.5);
            draw_set_color(c_white);
            draw_set_halign(fa_middle);
            draw_text(cx+8, cy+16, ds_list_find_value(characterNames, i));
            draw_set_alpha(1);
            }
        
        // draw all lasers
        draw_set_color(c_red);
        
        var laserAmount = ds_list_size(lasers);
        for (i = 0; i &lt; laserAmount; i += 3) {
            var lx = ds_list_find_value(lasers, i);
            var ly = ds_list_find_value(lasers, i+1);
            var laserX = ds_list_find_value(lasers, i+2);
            var dir = 1;
            if (laserX &lt; lx) dir = -1;
            draw_line_width(lx-8*dir+8, ly+7, laserX, ly+7, 2);
            }
        
        // draw water
        draw_set_alpha(.5);
        var buffer = 32;
        draw_rectangle_color(buffer, room_height-buffer, room_width-buffer, room_height-buffer-water_height, c_aqua, c_aqua, c_navy, c_navy, false);
        }
    }
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="114">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// toggle debug display

clientDebug = scr_toggle(clientDebug);
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
